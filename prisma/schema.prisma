generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String                   @id @default(cuid())
  email                String?                  @unique
  emailVerified        DateTime?
  image                String?
  name                 String?
  passwordHash         String?
  proExpiresAt         DateTime?
  proPlan              String?
  proSince             DateTime?
  stripeCustomerId     String?                  @unique
  stripeSubscriptionId String?                  @unique
  avatarId             String?
  accounts             Account[]
  attempts             Attempt[]
  emailTokens          EmailVerificationToken[]
  misses               MissedQuestion[]
  hostedParties        Party[]                  @relation("HostedParties")
  partyPlayers         PartyPlayer[]
  passwordTokens       PasswordResetToken[]
  sessions             Session[]
  studyAttempts        StudyAttempt[]
  studyDecks           StudyDeck[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expires])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expires])
}

model Question {
  id              String           @id @default(cuid())
  exam            String
  section         String
  topic           String?
  createdAt       DateTime         @default(now())
  answer          String
  choices         String[]
  explanation     String
  stem            String
  difficulty      Int
  aiExplanation   String?
  attempts        Attempt[]
  dailyQueueItems DailyQueueItem[]
  missedRecords   MissedQuestion[]
}

model VariantQuestion {
  id           String   @id @default(cuid())
  baselineId   String
  concept      String
  difficulty   String
  stem         String
  choicesJson  String
  correctIndex Int
  explanation  String?
  checksum     String   @unique
  createdAt    DateTime @default(now())

  @@index([concept, createdAt])
}

model Attempt {
  id         String          @id @default(cuid())
  userId     String
  questionId String
  timeMs     Int
  createdAt  DateTime        @default(now())
  isCorrect  Boolean
  userAnswer String
  concept    String?
  source     QuestionSource?
  question   Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId, createdAt])
}

model MissedQuestion {
  id           String    @id @default(cuid())
  userId       String
  questionId   String
  totalMisses  Int       @default(0)
  lastMissedAt DateTime  @default(now())
  lastServedAt DateTime?
  clearedAt    DateTime?
  createdAt    DateTime  @default(now())
  question     Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId, clearedAt, lastServedAt])
  @@index([userId, lastMissedAt])
}

model QuotaLog {
  id        String   @id @default(cuid())
  userId    String
  date      DateTime
  count     Int      @default(0)
  createdAt DateTime @default(now())

  @@unique([userId, date], name: "userId_date")
}

model DailyQueueItem {
  id         String    @id @default(cuid())
  userId     String
  date       DateTime
  questionId String
  order      Int
  servedAt   DateTime?
  question   Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, date, order])
  @@index([userId, date, servedAt])
  @@index([questionId])
}

model StudyDeck {
  id                String           @id @default(cuid())
  userId            String
  title             String
  description       String?
  shareId           String           @unique
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  sourceText        String?
  regenerateCount   Int              @default(0)
  lastRegeneratedAt DateTime?
  shareEditId       String?          @unique
  shareExpiresAt    DateTime?
  parties           Party[]
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  flashcards        StudyFlashcard[]
  questions         StudyQuestion[]
}

model StudyQuestion {
  id           String            @id @default(cuid())
  deckId       String
  order        Int
  prompt       String
  choices      String[]
  correctIndex Int
  explanation  String?
  createdAt    DateTime          @default(now())
  submissions  PartySubmission[]
  attempts     StudyAttempt[]
  deck         StudyDeck         @relation(fields: [deckId], references: [id], onDelete: Cascade)

  @@unique([deckId, order])
  @@index([deckId, order])
}

model StudyFlashcard {
  id          String                     @id @default(cuid())
  deckId      String
  order       Int
  front       String
  back        String
  createdAt   DateTime                   @default(now())
  submissions PartyFlashcardSubmission[]
  deck        StudyDeck                  @relation(fields: [deckId], references: [id], onDelete: Cascade)

  @@unique([deckId, order])
  @@index([deckId, order])
}

model StudyAttempt {
  id         String        @id @default(cuid())
  userId     String
  questionId String
  isCorrect  Boolean
  createdAt  DateTime      @default(now())
  question   StudyQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model Party {
  id                   String                     @id @default(cuid())
  deckId               String
  joinCode             String                     @unique
  status               PartyStatus                @default(LOBBY)
  currentQuestionIndex Int                        @default(0)
  questionStartedAt    DateTime?
  hostUserId           String?
  hostPlayerId         String?
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt
  endedAt              DateTime?
  expiresAt            DateTime
  answerRevealedAt     DateTime?
  isPublic             Boolean                    @default(false)
  joinLocked           Boolean                    @default(false)
  mode                 PartyMode                  @default(QUIZ)
  pauseStartedAt       DateTime?
  pausedMs             Int                        @default(0)
  questionDurationSec  Int                        @default(25)
  deck                 StudyDeck                  @relation(fields: [deckId], references: [id], onDelete: Cascade)
  hostUser             User?                      @relation("HostedParties", fields: [hostUserId], references: [id])
  flashcardSubmissions PartyFlashcardSubmission[]
  players              PartyPlayer[]
  submissions          PartySubmission[]

  @@index([deckId, createdAt])
}

model PartyPlayer {
  id                   String                     @id @default(cuid())
  partyId              String
  name                 String
  score                Int                        @default(0)
  playerToken          String                     @unique
  joinedAt             DateTime                   @default(now())
  lastSeenAt           DateTime                   @default(now())
  leftAt               DateTime?
  avatarId             String?
  bonusScore           Int                        @default(0)
  kickedAt             DateTime?
  userId               String?
  flashcardSubmissions PartyFlashcardSubmission[]
  party                Party                      @relation(fields: [partyId], references: [id], onDelete: Cascade)
  user                 User?                      @relation(fields: [userId], references: [id])
  submissions          PartySubmission[]

  @@index([partyId, joinedAt])
}

model PartySubmission {
  id            String        @id @default(cuid())
  partyId       String
  partyPlayerId String
  questionId    String
  answerIndex   Int
  isCorrect     Boolean
  createdAt     DateTime      @default(now())
  timeMs        Int?
  party         Party         @relation(fields: [partyId], references: [id], onDelete: Cascade)
  player        PartyPlayer   @relation(fields: [partyPlayerId], references: [id], onDelete: Cascade)
  question      StudyQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([partyPlayerId, questionId])
  @@index([partyId, questionId])
}

model PartyFlashcardSubmission {
  id            String         @id @default(cuid())
  partyId       String
  partyPlayerId String
  flashcardId   String
  knewIt        Boolean
  timeMs        Int?
  createdAt     DateTime       @default(now())
  flashcard     StudyFlashcard @relation(fields: [flashcardId], references: [id], onDelete: Cascade)
  party         Party          @relation(fields: [partyId], references: [id], onDelete: Cascade)
  player        PartyPlayer    @relation(fields: [partyPlayerId], references: [id], onDelete: Cascade)

  @@unique([partyPlayerId, flashcardId])
  @@index([partyId, flashcardId])
}

enum QuestionSource {
  BASELINE
  VARIANT
}

enum PartyStatus {
  LOBBY
  ACTIVE
  COMPLETE
}

enum PartyMode {
  QUIZ
  FLASHCARDS
}
